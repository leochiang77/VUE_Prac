run_settings_box.py

import numpy as np
import cv2
import os


from utils import tools, settings_box
from config import config_utils


def load_globals():
    global config, IMG_SCALE, BOX_SIZE, JSON_PATH, MODEL_PATH, IMG, \
        img_path, file_name_with_extension, image_ID, MAX_POINT

    config = config_utils.load_config()

    IMG_SCALE = config['image']['scale']
    BOX_SIZE = config['box']['init_size']
    JSON_PATH = config['box']['save_box_path']

    MODEL_PATH = config['model']['path']

    IMG = config['runMode']['run_settings_box_path']

    img_path = os.path.join(MODEL_PATH, IMG)
    file_name_with_extension = os.path.basename(img_path)
    image_ID = os.path.splitext(file_name_with_extension)[0]

    MAX_POINT = config['model'][image_ID]


def main():

    load_globals()

    #  img
    clear_img = cv2.imread(img_path)

    # init previous boxs record
    image_init_box = clear_img.copy()

    try:
        init_box_points, init_directions_points = tools.load_box(
            image_ID, JSON_PATH)
        for i, (point, direction) in enumerate(zip(init_box_points, init_directions_points)):
            tools.draw_box(image=image_init_box,
                           center_point=point, box_num=i, frame_size=BOX_SIZE, direction=direction)
    except:
        print(f"No {image_ID} model record.")

    # select N coords
    print("Please select the desired range:")
    selector = settings_box.PointSelector(
        image_init_box, clear_img, max_points=MAX_POINT, box_size=BOX_SIZE, image_ID=image_ID, json_path=JSON_PATH)
    selector.run()


if __name__ == '__main__':
    main()

-----------------------------------------------------------------
utils/settings_box.py

import cv2
from utils import tools
import os
import json
import numpy as np


class PointSelector:
    def __init__(self, image_init_box: np.ndarray, image_rgb: np.ndarray, image_ID: str, json_path: str,
                 max_points: int = 5, box_size: int = 100):
        """
        初始化 PointSelector 類別。

        參數:
            image_init_box (np.ndarray): 初始顯示圖像，必須是 BGR 格式的圖像。
            image_rgb (np.ndarray): RGB 格式的圖像，用於標註點後的顯示。
            image_ID (str): 圖像的唯一標識符。
            json_path (str): 保存點和方向的 JSON 文件路徑。
            max_points (int): 允許的最大點數（默認為 5）。
            box_size (int): 繪製框的尺寸（默認為 100）。
        """
        self.max_points = max_points
        self.points = []
        self.confirm = False
        self.image_init_box = image_init_box.copy()
        self.image_rgb = image_rgb.copy()
        self.mouse_position = (0, 0)
        self.show_mouse_frame = True
        self.init_mode = True
        self.box_size = box_size
        self.selected_box_index = 0  # Start from the first box
        self.directions = []
        self.image_ID = image_ID
        self.json_path = json_path

        cv2.namedWindow('Image')
        cv2.imshow('Image', self.image_init_box)
        cv2.setMouseCallback('Image', self.mouse_callback)

    def mouse_callback(self, event: int, x: int, y: int, flags: int, param: any):
        """
        鼠標回調函數，處理點擊事件和鼠標移動事件。

        參數:
            event (int): 鼠標事件類型。
            x (int): 鼠標在圖像上的 x 坐標。
            y (int): 鼠標在圖像上的 y 坐標。
            flags (int): 事件標誌。
            param (Optional[int]): 附加參數。
        """
        if event == cv2.EVENT_LBUTTONDOWN:
            if len(self.points) < self.max_points and not self.confirm:
                self.points.append((x, y))
                self.directions.append(None)  # Initialize with None direction
                self.init_mode = False  # Switch to image_rgb mode
                self.draw_image()

            if len(self.points) == self.max_points and not self.confirm:
                self.confirm = True
                self.show_mouse_frame = False
                print(
                    "Points confirmed. Select direction for each box by pressing 1, 2, 3, or 4.")

        elif event == cv2.EVENT_MOUSEMOVE:
            self.mouse_position = (x, y)
            self.draw_image()

    def draw_image(self):
        """
        繪製圖像，包括顯示點、框架和指示文字。
        """
        if self.init_mode:
            draw_image = self.image_init_box.copy()
        else:
            draw_image = self.image_rgb.copy()

        for i, point in enumerate(self.points):
            tools.draw_box(image=draw_image, center_point=point, box_num=i,
                           circle_rgb=(0, 0, 255), rectangle_rgb=(0, 192, 255),
                           text_rgb=(0, 0, 255), frame_size=self.box_size)
            if self.directions[i]:
                self.draw_line(draw_image, point, self.directions[i])

        if self.show_mouse_frame:
            self.draw_frame(draw_image)

        # Add the instructions
        if not self.confirm:
            self.add_text(
                draw_image, "Please click to add a box (" + str(self.max_points) + " boxes).")
        else:
            self.add_text(
                draw_image, "Press [1]:Vertical, [2]:Horizontal, [3]:Positive Slope, [4]:Negative Slope.")

        # Add the second line of instructions
        self.add_text(
            draw_image, "[Enter]: finish, [C]: clear, [ESC]: exit", offset=(0, 30))

        cv2.imshow('Image', draw_image)

    def draw_frame(self, image: np.ndarray):
        """
        在圖像上繪製鼠標位置的框架。

        參數:
            image (np.ndarray): 要繪製框架的圖像。
        """
        x, y = self.mouse_position
        frame_size = self.box_size
        top_left = (x - frame_size // 2, y - frame_size // 2)
        bottom_right = (x + frame_size // 2, y + frame_size // 2)
        cv2.rectangle(image, top_left, bottom_right, (0, 255, 0), 2)

    def draw_line(self, image: np.ndarray, center_point: tuple, direction: str):
        """
        根據方向在圖像上繪製線條。

        參數:
            image (np.ndarray): 要繪製線條的圖像。
            center_point (Tuple[int, int]): 盒子的中心點座標。
            direction (str): 方向類型，可以是 "Vertical"、"Horizontal"、"Positive Slope" 或 "Negative Slope"。
        """
        x, y = center_point
        half_size = self.box_size // 2
        if direction == "Vertical":
            cv2.line(image, (x, y - half_size),
                     (x, y + half_size), (255, 0, 0), 2)
        elif direction == "Horizontal":
            cv2.line(image, (x - half_size, y),
                     (x + half_size, y), (255, 0, 0), 2)
        elif direction == "Positive Slope":
            cv2.line(image, (x - half_size, y + half_size),
                     (x + half_size, y - half_size), (255, 0, 0), 2)
        elif direction == "Negative Slope":
            cv2.line(image, (x - half_size, y - half_size),
                     (x + half_size, y + half_size), (255, 0, 0), 2)

    def add_text(self, image: np.ndarray, text: str, offset: tuple = (0, 0)):
        """
        在圖像上添加文字。

        參數:
            image (np.ndarray): 要添加文字的圖像。
            text (str): 要顯示的文字。
            offset (Tuple[int, int]): 文字位置的偏移量（默認為 (0, 0)）。
        """
        font = cv2.FONT_HERSHEY_SIMPLEX
        bottom_left_corner = (10 + offset[0], 30 + offset[1])
        font_scale = 0.6
        font_color = (0, 102, 255)
        line_type = 2

        cv2.putText(image, text,
                    bottom_left_corner,
                    font,
                    font_scale,
                    font_color,
                    line_type)

    def save_json(self, image_ID: str, json_path: str):
        """
        將點和方向保存到 JSON 文件中。

        參數:
            image_ID (str): 圖像的唯一標識符。
            json_path (str): JSON 文件的路徑。
        """
        points_dict = {}
        if os.path.exists(json_path):
            with open(json_path, 'r') as json_file:
                points_dict = json.load(json_file)

        points_dict[image_ID] = {
            "points": self.points,
            "directions": self.directions
        }

        with open(json_path, 'w') as json_file:
            json.dump(points_dict, json_file, indent=4)

        print(f"Points saved to {json_path}.")

    def run(self):
        """
        啟動點選擇器，進入主循環以處理用戶輸入。
        """
        while True:
            key = cv2.waitKey(1) & 0xFF

            if cv2.getWindowProperty('Image', cv2.WND_PROP_VISIBLE) < 1:
                print("cv2 has been closed.")
                break
            if key == 27:  # Check if 'ESC' is pressed
                print("cv2 has been closed.")
                break
            elif key == ord('c'):  # Clear points if 'C' is pressed
                self.points = []
                self.directions = []
                self.confirm = False
                self.show_mouse_frame = True
                self.init_mode = True  # Reset to initial mode
                self.selected_box_index = 0  # Reset selected box index
                self.draw_image()
                print("Points have been cleared.")

            elif self.confirm and key in [ord('1'), ord('2'), ord('3'), ord('4')]:
                if self.selected_box_index < self.max_points:
                    direction_map = {ord('1'): "Vertical", ord('2'): "Horizontal", ord(
                        '3'): "Positive Slope", ord('4'): "Negative Slope"}
                    self.directions[self.selected_box_index] = direction_map[key]
                    print(
                        f"Direction for box {self.selected_box_index + 1} set to {self.directions[self.selected_box_index]}")
                    self.selected_box_index += 1
                    self.draw_image()
                    if self.selected_box_index == self.max_points:
                        self.show_mouse_frame = False
                        print(
                            "All directions set. Press Enter to print or C to clear.")

            # Check if 'Enter' is pressed after confirming points
            elif (self.confirm and key == 13) and None not in self.directions:
                print("\nPrinting confirmed points and directions:")
                for i, point in enumerate(self.points):
                    direction = self.directions[i] if self.directions[i] else "Not set"
                    print(
                        f"Point {i+1}: ({point[0]}, {point[1]}), Direction: {direction}")
                self.save_json(self.image_ID, self.json_path)
                break

        cv2.destroyAllWindows()


# Example usage:
# image_init_box = cv2.imread('init_box_image.png')
# image_rgb = cv2.imread('rgb_image.png')
# selector = PointSelector(image_init_box, image_rgb)
# selector.run()

------------------------------------------------------------------------
main_UI.py

import os
import cv2
import yaml
import subprocess
import threading
import tkinter as tk
from tkinter import ttk, messagebox, filedialog
from config import config_utils
from utils import tools
from PIL import Image, ImageTk

import create_models_img
import run_settings_box
import create_table


config = config_utils.load_config()
original_config = config_utils.load_config()


class App(tk.Tk):
    def __init__(self):
        super().__init__()

        self.force_stopped = False
        self.single_process = None

        self.title("Analysis U-Shape System")
        self.geometry('410x600')
        self.resizable(False, False)
        tools.center_window(self)

        self.notebook = ttk.Notebook(self)
        self.notebook.pack(expand=True, fill='both')
        self.notebook.bind("<<NotebookTabChanged>>", self.on_tab_changed)

        self.entry_widgets = {}
        self.boolean_vars = {}

        self.create_tabs()

    # all tab

    def create_tabs(self):
        self.create_setting_tab("0-InitSetting", ["location", "image", "box", "logs", "env", "mysql"], {
            "location": 25, "image": 10, "box": 20, "logs": 10, "env": 15, "mysql": 15}, base_button=True)
        self.create_setting_tab("0-ModeSetting", ["saveMode", "model"], {
            "saveMode": 20,  "model": 10}, base_button=True, create_button=True)
        self.create_setting_tab("1-Create", ["createModel"], {
            "createModel": 10}, create_model_tab=True)

        self.create_main_tab("2-BoxSetting")
        self.create_train_tab("3-Train", "runMode", entry_width=30)

    # tab 0. and 1.
    def create_setting_tab(self, tab_name, section_order, entry_widths, create_model_tab=False, base_button=False, create_button=False):
        scrollable_frame = self._create_template_tab(tab_name)

        for section in section_order:
            self.create_setting_section(scrollable_frame, section,
                                        entry_widths.get(section, 45))

        button_frame = ttk.Frame(scrollable_frame)
        button_frame.pack(pady=10)
        if base_button:
            save_button = ttk.Button(
                button_frame, text="Save", command=self.save_parameters)
            save_button.pack(side='left', padx=5)
            save_new__button = ttk.Button(
                button_frame, text="Save new location", command=self.save_new_parameters_location)
            save_new__button.pack(side='left', padx=5)
            reset_button = ttk.Button(
                button_frame, text="Reset", command=self.reset_parameters)
            reset_button.pack(side='left', padx=5)

        if create_model_tab:
            self.create_model_section(scrollable_frame)

        if create_button:
            self.create_sql_section(scrollable_frame)

    # tab 2.
    def create_main_tab(self, tab_name):
        scrollable_frame = self._create_template_tab(tab_name)
        self.create_box_section(scrollable_frame)

    # tab3
    def create_train_tab(self, tab_name, section, entry_width):
        scrollable_frame = self._create_template_tab(tab_name)
        self.create_train_section(scrollable_frame, section, entry_width)

    # tab by scroll function
    def _create_template_tab(self, tab_name):
        frame = ttk.Frame(self.notebook)
        canvas = tk.Canvas(frame)
        scrollbar = ttk.Scrollbar(
            frame, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)

        scrollable_frame.bind(
            "<Configure>", lambda e: self._configure_canvas(canvas, scrollable_frame))
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)

        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

        self.notebook.add(frame, text=tab_name)
        frame.canvas = canvas
        frame.scrollable_frame = scrollable_frame

        return scrollable_frame

    # details 0. section
    def create_setting_section(self, parent, section, entry_width):
        settings = config.get(section, {})
        section_label = ttk.Label(
            parent, text=section, font=('Arial', 12, 'bold'))
        section_label.pack(anchor='w', padx=10, pady=5)

        for key, value in settings.items():
            frame = ttk.Frame(parent)
            frame.pack(fill='x', padx=10, pady=2)

            label = ttk.Label(frame, text=key, width=25)
            if entry_width > 40:
                label.pack(side='top', anchor='w', pady=2)
            else:
                label.pack(side='left')

            if isinstance(value, bool):

                entry_frame = ttk.Frame(frame, width=entry_width)
                entry_frame.pack(fill='x', side='left', expand=True)

                var = tk.BooleanVar(value=value)
                self.boolean_vars[f"{section}_{key}"] = var

                true_rb = ttk.Radiobutton(
                    entry_frame, text="True", variable=var, value=True)
                true_rb.pack(side='right')

                false_rb = ttk.Radiobutton(
                    entry_frame, text="False", variable=var, value=False)
                false_rb.pack(side='right', padx=(0, 10))
            else:
                entry = ttk.Entry(frame, width=entry_width)
                entry.insert(0, str(value))
                entry.pack(side='right',  fill='x', padx=(0, 10))

                self.entry_widgets[f"{section}_{key}"] = entry

                if not "path" in key.lower() and not "folder" in key.lower():
                    if isinstance(value, (int, float)):
                        entry.bind('<FocusOut>', lambda e, key=key, section=section: self.validate_number(
                            e.widget, section, key))

            unit_label = ttk.Label(frame, text="")
            unit_label.pack(side='left')

        separator = ttk.Separator(parent, orient='horizontal')
        separator.pack(fill='x', padx=10, pady=5)

    def create_sql_section(self, parent):
        section_label = ttk.Label(
            parent, text="create MySQL table", font=('Arial', 12, 'bold'))
        section_label.pack(anchor='w', padx=10, pady=(25, 5))

        # status label
        status_label = ttk.Label(
            parent, text='', font=('Arial', 10))
        status_label.pack(anchor='w', padx=10, pady=10)
        status_label.config(text='Ready.')

        separator = ttk.Separator(parent, orient='horizontal')
        separator.pack(fill='x', padx=10, pady=5)

        button_frame = ttk.Frame(parent)
        button_frame.pack(pady=10)

        create_button = ttk.Button(
            button_frame, text="generate", command=lambda: self.run_generate_sql(status_label))
        create_button.pack(side='left', padx=5)

    # details 1. setction

    def create_model_section(self, parent):

        dicttxt = {'pathL': 'Process Image Path ',
                   'tips': '*need [folder name]/[img name].jpg .', 'yaml': 'create_models_img_path'}
        info_text, status_label = self._runmode_section(parent, dict=dicttxt)

        info_text.insert(tk.END, '\n1. Please click ')
        info_text.insert(tk.END, '"Run"', 'bold_color')
        info_text.insert(tk.END, ' to start create template image.\n\n')

        info_text.insert(tk.END, '2. The image will save to ')
        info_text.insert(
            tk.END, '"'+config['model']['path']+'tmp".', 'bold_color')
        info_text.insert(tk.END, '\n\n')

        info_text.insert(tk.END, '3. You can remove the ')
        info_text.insert(tk.END, '"noise area"', 'bold_color')
        info_text.insert(tk.END, ' through a little painter.\n\n')

        info_text.insert(
            tk.END, '4. If this image is available, please copy it to ')
        info_text.insert(
            tk.END, '"'+config['model']['path']+'".', 'bold_color')
        info_text.insert(tk.END, '\n\n')

        info_text.config(state=tk.DISABLED)

        # add image label to display the processed image
        self.image_label = ttk.Label(parent)
        self.image_label.pack(anchor='w', padx=10, pady=(0, 2))

        create_model_frame = ttk.Frame(parent)
        create_model_frame.pack(padx=0, pady=2)

        # button
        self.create_model_button = ttk.Button(
            create_model_frame, text="Run", command=lambda: self.create_model(status_label))
        self.create_model_button.pack(side='left', padx=5)

        open_folder_button = ttk.Button(
            create_model_frame, text="Open Folder", command=self.open_folder)
        open_folder_button.pack(side='left', padx=5)

    # details 2. section
    def create_box_section(self, parent):

        dicttxt = {'pathL': 'Model Image Path ',
                   'tips': '*need [model ID].jpg .', 'yaml': 'run_settings_box_path'}
        info_text, status_label = self._runmode_section(
            parent, dict=dicttxt, is_small_entry=True)

        info_text.insert(tk.END, '\n1. Please click ')
        info_text.insert(tk.END, '"Run"', 'bold_color')
        info_text.insert(tk.END, ' to start Run Box Setting.\n')

        info_text.insert(tk.END, '\n2. You can adjust the ')
        info_text.insert(tk.END, '"number of Boxes"', 'bold_color')
        info_text.insert(tk.END, ' in 0-ModeSetting.\n')

        info_text.insert(tk.END, '\n3. If it has already been set, you ')
        info_text.insert(tk.END, '"don’t need to set it again"', 'bold_color')
        info_text.insert(tk.END, ' .\n')

        create_model_frame = ttk.Frame(parent)
        create_model_frame.pack(padx=0, pady=2)

        # button
        self.create_box_button = ttk.Button(
            create_model_frame, text="Run", command=lambda: self.run_box(status_label))
        self.create_box_button.pack(side='left', padx=5)

    def create_train_section(self, parent, section, entry_width):

        section_label = ttk.Label(
            parent, text=section, font=('Arial', 12, 'bold'))
        section_label.pack(anchor='w', padx=10, pady=5)

        # tips
        content_label = ttk.Label(
            parent, text="*need [folder name]/[img name].jpg or [folder name]/", font=('Arial', 10), foreground='blue')
        content_label.pack(anchor='w', padx=10, pady=(0, 3))

        # run mode yaml
        # mode single file
        frame1 = ttk.Frame(parent)
        frame1.pack(fill='x', padx=10, pady=2)
        label = ttk.Label(frame1, text="main_by_single_file_path", width=25)
        label.pack(side='top', anchor='w', pady=2)

        entry1 = ttk.Entry(frame1, width=entry_width)
        entry1.insert(
            0, str(config.get('runMode', {}).get('main_by_single_file_path')))
        entry1.pack(side='left', expand=True, fill='x', padx=(0, 10))

        select_button_file = ttk.Button(
            frame1, text="Browse", command=lambda: self.select_file(entry1))
        select_button_file.pack(side='left')

        self.entry_widgets["runMode_main_by_single_file_path"] = entry1

        # mode specify folder
        frame2 = ttk.Frame(parent)
        frame2.pack(fill='x', padx=10, pady=2)
        labe2 = ttk.Label(frame2, text="main_by_specify_folder_path", width=25)
        labe2.pack(side='top', anchor='w', pady=2)

        entry2 = ttk.Entry(frame2, width=entry_width)
        entry2.insert(
            0, str(config.get('runMode', {}).get('main_by_specify_folder_path')))
        entry2.pack(side='left', expand=True, fill='x', padx=(0, 10))

        select_button_folder = ttk.Button(
            frame2, text="Browse", command=lambda: self.select_folder(entry2))
        select_button_folder.pack(side='left')

        self.entry_widgets["runMode_main_by_specify_folder_path"] = entry2

        # separator
        separator = ttk.Separator(parent, orient='horizontal')
        separator.pack(fill='x', padx=10, pady=5)

        # reset button
        reset_frame = ttk.Frame(parent)
        reset_frame.pack(padx=0, pady=2)
        reset_button = ttk.Button(
            reset_frame, text="Reset", command=self.reset_parameters)
        reset_button.pack(side='left', padx=5)

        # Run label
        section_label = ttk.Label(
            parent, text='RUN ', font=('Arial', 12, 'bold'))
        section_label.pack(anchor='w', padx=10, pady=10)

        # text
        # Create a Text widget for formatted output
        info_text = tk.Text(parent, height=9, width=50, wrap='word',
                            borderwidth=0, bg='white', font=('Arial', 10))
        info_text.pack(anchor='w', padx=10, pady=(0, 10))

        info_text.tag_config('bold_color', font=(
            'Arial', 10, 'bold'), foreground='blue')

        info_text.insert(tk.END, '\n1. ')
        info_text.insert(tk.END, '"Run Single File"', 'bold_color')
        info_text.insert(tk.END, ' is calculating a single image.\n')

        info_text.insert(tk.END, '\n2. ')
        info_text.insert(tk.END, '"Run Specify Folder"', 'bold_color')
        info_text.insert(tk.END, ' is calculating a single folder.\n')

        info_text.insert(
            tk.END, '\n3. When calculation completed, the average value of  ')
        info_text.insert(tk.END, '"Each Box"', 'bold_color')
        info_text.insert(tk.END, ' will be saved as a ')
        info_text.insert(tk.END, '"List"', 'bold_color')
        info_text.insert(tk.END, ' .\n')

        # status label
        status_label = ttk.Label(
            parent, text='', font=('Arial', 10))
        status_label.pack(anchor='w', padx=10, pady=10)
        status_label.config(text='Ready.')

        # separator
        separator = ttk.Separator(parent, orient='horizontal')
        separator.pack(fill='x', padx=10, pady=2)

        create_model_frame = ttk.Frame(parent)
        create_model_frame.pack(padx=0, pady=2)

        # separator
        separator = ttk.Separator(parent, orient='horizontal')
        separator.pack(fill='x', padx=10, pady=5)

        create2_frame = ttk.Frame(parent)
        create2_frame.pack(padx=0, pady=2)

        # button
        self.single_file_button = ttk.Button(
            create_model_frame, text="[1] Run Single File", command=lambda: self.run_single_file(status_label))
        self.single_file_button.pack(side='left', padx=5)

        self.specify_folder_button = ttk.Button(
            create_model_frame, text="[2] Run Specify Folder", command=lambda: self.run_specify_folder(status_label))
        self.specify_folder_button.pack(side='left', padx=5)

        self.all_folder_button = ttk.Button(
            create_model_frame, text="[3] Run All Folder", command=lambda: self.run_all_folder(status_label))
        self.all_folder_button.pack(side='left', padx=5)

        # button2
        open_folder_button = ttk.Button(
            create2_frame, text="Open Folder", command=self.open_result_folder)
        open_folder_button.pack(side='left', padx=5)

        style = ttk.Style()
        style.configure('Red.TButton', foreground='red')
        self.force_interrupt_button = ttk.Button(
            create2_frame, text="Force Interrupt", style='Red.TButton',
            command=lambda: self.force_interrupt(status_label), state='disabled')
        self.force_interrupt_button.pack(side='left', padx=5)

    def _runmode_section(self, parent, dict, is_small_entry=False):
        # Path label
        section_label_IMG = ttk.Label(
            parent, text=dict['pathL'], font=('Arial', 12, 'bold'))
        section_label_IMG.pack(anchor='w', padx=10, pady=10)

        # tips
        content_label = ttk.Label(
            parent, text=dict['tips'], font=('Arial', 10), foreground='blue')
        content_label.pack(anchor='w', padx=10, pady=(0, 3))

        # path Entry
        if is_small_entry:
            entry_frame = ttk.Frame(parent)
            entry_frame.pack(fill='x', padx=10, pady=2)
            label = ttk.Label(entry_frame, text="model ID img: ", width=15)
            label.pack(side='left')

            entry = ttk.Entry(entry_frame, width=15)
            entry.insert(
                0, str(config.get('runMode', {}).get(dict['yaml'])))

            select_button_file = ttk.Button(
                entry_frame, text="Browse", command=lambda: self.select_model_file(entry))
            select_button_file.pack(side='right')
            entry.pack(side='right', anchor='w', padx=10, pady=2)

        else:
            frame1 = ttk.Frame(parent)
            frame1.pack(fill='x', padx=10, pady=2)

            entry = ttk.Entry(frame1, width=30)
            entry.insert(
                0, str(config.get('runMode', {}).get(dict['yaml'])))
            entry.pack(side='left', expand=True, fill='x', padx=(0, 10))

            select_button_file = ttk.Button(
                frame1, text="Browse", command=lambda: self.select_file(entry))
            select_button_file.pack(side='left')

        self.entry_widgets["runMode_"+dict['yaml']] = entry

        # separator
        separator = ttk.Separator(parent, orient='horizontal')
        separator.pack(fill='x', padx=10, pady=5)

        # reset button
        reset_frame = ttk.Frame(parent)
        reset_frame.pack(padx=0, pady=2)
        reset_button = ttk.Button(
            reset_frame, text="Reset", command=self.reset_parameters)
        reset_button.pack(side='left', padx=5)

        # Run label
        section_label = ttk.Label(
            parent, text='RUN ', font=('Arial', 12, 'bold'))
        section_label.pack(anchor='w', padx=10, pady=10)

        # text
        # Create a Text widget for formatted output
        info_text = tk.Text(parent, height=9, width=50, wrap='word',
                            borderwidth=0, bg='white', font=('Arial', 10))
        info_text.pack(anchor='w', padx=10, pady=(0, 10))

        info_text.tag_config('bold_color', font=(
            'Arial', 10, 'bold'), foreground='blue')

        # status label
        status_label = ttk.Label(
            parent, text='', font=('Arial', 10))
        status_label.pack(anchor='w', padx=10, pady=10)
        status_label.config(text='Ready.')

        # separator
        separator = ttk.Separator(parent, orient='horizontal')
        separator.pack(fill='x', padx=10, pady=2)

        return info_text, status_label

    def create_model(self, status_label):
        status_label.config(text='Executing...', foreground='black')
        self.create_model_button.config(state='disabled')
        self.save_parameters(showbox=False)
        self.update()
        try:
            offset_img = create_models_img.main()

            max_width = 360
            max_height = 500
            height, width = offset_img.shape[:2]

            if width > max_width or height > max_height:
                scaling_factor = min(max_width / width, max_height / height)
                new_width = int(width * scaling_factor)
                new_height = int(height * scaling_factor)
                offset_img = cv2.resize(offset_img, (new_width, new_height))

            # Convert the OpenCV image to PIL format and then to ImageTk format
            offset_img_rgb = cv2.cvtColor(offset_img, cv2.COLOR_BGR2RGB)
            pil_image = Image.fromarray(offset_img_rgb)
            tk_image = ImageTk.PhotoImage(pil_image)

            # Update the image label with the new image
            self.image_label.config(image=tk_image)
            self.image_label.image = tk_image

            status_label.config(
                text='Finish ! -> save to ['+config['model']['path']+'tmp].',
                foreground='green')

        except Exception as e:
            status_label.config(
                text='Error ! Not Found This Image.', foreground='red')
            print(f"Exception:{str(e)}")
        self.create_model_button.config(state='normal')

    def run_box(self, status_label):
        status_label.config(text='Executing...', foreground='black')
        self.create_box_button.config(state='disabled')
        self.save_parameters(showbox=False)
        self.update()
        try:
            run_settings_box.main()

            status_label.config(
                text='Finish !box positioning setting completed.',
                foreground='green')
        except Exception as e:
            status_label.config(
                text='Error ! Not Found This Image.', foreground='red')
            print(f"Exception:{str(e)}")
        self.create_box_button.config(state='normal')

    def run_single_file(self, status_label):
        status_label.config(text='Executing...', foreground='black')
        self.save_parameters(showbox=False)
        self.run_script_in_new_cmd('main_by_singleFile.py', status_label)
        self.update()

    def run_specify_folder(self, status_label):
        status_label.config(text='Executing...', foreground='black')
        self.save_parameters(showbox=False)
        self.run_script_in_new_cmd('main_by_specifyFolder.py', status_label)
        self.update()

    def run_all_folder(self, status_label):
        status_label.config(text='Executing...', foreground='black')
        self.save_parameters(showbox=False)
        self.run_script_in_new_cmd('main_by_allFolder.py', status_label)
        self.update()

    def run_generate_sql(self, status_label):
        status_label.config(text='Executing...', foreground='black')
        create_table.main()
        status_label.config(text='Done.', foreground='black')
        self.update()

    def select_folder(self, entry):
        folder_path = filedialog.askdirectory(
            initialdir=config["location"]["target_folder"])
        if folder_path:
            folder_name = folder_path.split('/')[-1]
            folder_path_with_slash = folder_name + '/'
            entry.delete(0, tk.END)
            entry.insert(0, folder_path_with_slash)

    def select_file(self, entry):

        file_path = filedialog.askopenfilename(
            initialdir=config["location"]["target_folder"])
        if file_path:
            folder_name = os.path.basename(os.path.dirname(file_path))
            file_name = os.path.basename(file_path)
            entry_value = f"{folder_name}/{file_name}"
            entry.delete(0, tk.END)
            entry.insert(0, entry_value)

    def select_model_file(self, entry):

        file_path = filedialog.askopenfilename(
            initialdir=config["model"]["path"])
        if file_path:
            file_name = os.path.basename(file_path)
            entry_value = f"{file_name}"
            entry.delete(0, tk.END)
            entry.insert(0, entry_value)

    def validate_number(self, widget, section, key):
        value = widget.get()
        try:
            if isinstance(config[section][key], int):
                config[section][key] = int(value)
            else:
                config[section][key] = float(value)
        except ValueError:
            messagebox.showerror(
                "Invalid Input", f"'{key}' in {section} should be a integer/float")
            widget.focus_set()

    def save_parameters(self, showbox=True):
        # boolean
        for key, var in self.boolean_vars.items():
            section, param = key.split('_', 1)
            config[section][param] = var.get()

        # value
        for key, entry in self.entry_widgets.items():
            section, param = key.split('_', 1)
            original_value = original_config[section][param]
            entry_value = entry.get()

            if isinstance(original_value, int):
                try:
                    config[section][param] = int(entry_value)
                except ValueError:
                    messagebox.showerror(
                        "Invalid Input", f"'{param}' in {section} should be an integer")
                    entry.focus_set()
                    return
            elif isinstance(original_value, float):
                try:
                    config[section][param] = float(entry_value)
                except ValueError:
                    messagebox.showerror(
                        "Invalid Input", f"'{param}' in {section} should be a float")
                    entry.focus_set()
                    return
            else:
                config[section][param] = entry_value

        tools.save_config(config, showbox=showbox)

    def save_new_parameters_location(self, showbox=True):
        for key, entry in self.entry_widgets.items():
            section, param = key.split('_', 1)
            config[section][param] = entry.get()

        new_config = config.get('location', {})

        # Opens a file dialog box to allow the user to select a saved path
        file_path = filedialog.asksaveasfilename(
            defaultextension=".yaml",
            filetypes=[("YAML files", "*.yaml"), ("All files", "*.*")],
            title="Save as",
            initialdir="config/"
        )

        if file_path:
            # Save current configuration to selected file
            with open(file_path, 'w') as file:
                yaml.dump(new_config, file, default_flow_style=False)
            print(f"New configuration saved to {file_path}")
            if showbox:
                messagebox.showinfo(
                    "Saved", "new configuration has been saved!")

    def reset_parameters(self):
        global config
        config = config_utils.load_config()  # Reset to original config
        for section, settings in config.items():
            for key, value in settings.items():
                if isinstance(value, bool):
                    var = self.boolean_vars.get(f"{section}_{key}")
                    if var:
                        var.set(value)
                else:
                    entry = self.entry_widgets.get(f"{section}_{key}")
                    if entry:
                        entry.delete(0, tk.END)
                        entry.insert(0, str(value))

        self.update()

    def on_tab_changed(self, event):

        self.reset_parameters()

        selected_tab = event.widget.select()
        frame = event.widget.nametowidget(selected_tab)
        canvas = frame.canvas
        scrollable_frame = frame.scrollable_frame

        tab_name = event.widget.tab(event.widget.select(), "text")

        if tab_name == "0-ModeSetting":
            self.clear_settings_sections(scrollable_frame)
            self.create_setting_section(scrollable_frame, "saveMode", 15)
            self.create_setting_section(scrollable_frame, "model", 15)
            button_frame = ttk.Frame(scrollable_frame)
            button_frame.pack(pady=10)

            save_button = ttk.Button(
                button_frame, text="Save", command=self.save_parameters)
            save_button.pack(side='left', padx=5)
            reset_button = ttk.Button(
                button_frame, text="Reset", command=self.reset_parameters)
            reset_button.pack(side='left', padx=5)

            self.create_sql_section(scrollable_frame)

        self._configure_canvas(canvas, scrollable_frame)

        self.update()

    def clear_settings_sections(self, parent):
        # Clear out old settings sections if needed
        for widget in parent.winfo_children():
            widget.destroy()

    def open_folder(self):
        full_path = os.path.join(
            os.getcwd(), config['model']['path'][:-1], 'tmp')

        if os.name == 'nt':  # For Windows
            os.system("explorer.exe %s" % full_path)

    def open_result_folder(self):
        full_path = os.path.join(
            os.getcwd(), config['image']['save_result_folder'][:-1])

        if os.name == 'nt':  # For Windows
            os.system("explorer.exe %s" % full_path)

    def force_interrupt(self, status_label):
        print("force interrupt")
        self.force_stopped = True
        self.single_process.terminate()
        self.single_process = None
        self.force_interrupt_button.config(state='disabled')
        self.single_file_button.config(state='normal')
        self.specify_folder_button.config(state='normal')
        self.all_folder_button.config(state='normal')
        status_label.config(text='force interrupt', foreground='red')

    def _configure_canvas(self, canvas, scrollable_frame):
        canvas.configure(scrollregion=canvas.bbox("all"))
        if canvas.bbox("all")[3] > canvas.winfo_height():
            self._bind_mousewheel(canvas)
        else:
            self._unbind_mousewheel(canvas)

    def _bind_mousewheel(self, canvas):
        # Adjust the amount scrolled by the mouse wheel
        canvas.bind_all(
            "<MouseWheel>", lambda event: self._on_mousewheel(event, canvas))

    def _unbind_mousewheel(self, canvas):
        # Unbind the mouse wheel when leaving the canvas
        canvas.unbind_all("<MouseWheel>")

    def _on_mousewheel(self, event, canvas):
        # Adjust the amount scrolled by the mouse wheel
        canvas.yview_scroll(int(-1*(event.delta/120)), "units")

    def run_script_in_new_cmd(self, script_path, status_label):
        try:
            python_folder = config["env"]["python_folder"]
            if python_folder:
                python_executable = os.path.join(python_folder, 'python.exe')
            else:
                python_executable = 'python'

            self.force_stopped = False
            self.single_process = subprocess.Popen(
                [python_executable, script_path])
            self.force_interrupt_button.config(state='normal')
            self.single_file_button.config(state='disabled')
            self.specify_folder_button.config(state='disabled')
            self.all_folder_button.config(state='disabled')

            # wait
            threading.Thread(target=self.wait_for_process,
                             args=(status_label,)).start()

        except FileNotFoundError:
            print("The file specified cannot be found or the path is wrong.")

    def wait_for_process(self, status_label):
        self.single_process.wait()
        if not self.force_stopped:
            status_label.config(
                text='Finish ! -> save to [' +
                config['image']['save_result_folder'] + ']',
                foreground='green')
        self.single_process = None
        self.force_interrupt_button.config(state='disabled')
        self.single_file_button.config(state='normal')
        self.specify_folder_button.config(state='normal')
        self.all_folder_button.config(state='normal')


if __name__ == "__main__":
    app = App()
    app.mainloop()
